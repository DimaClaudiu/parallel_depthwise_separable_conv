#include "utils.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

unsigned char clamp_to_byte(float byte)
{
    unsigned char clammped_byte;
    if (byte < 0)
        clammped_byte = 0;
    else if (byte > 255)
        clammped_byte = 255;
    else
        clammped_byte = byte;
    return clammped_byte;
}

// Reads a pnm binary image
Channels **read_image_pnm(char *filename, int *width, int *height)
{
    FILE *fp;

    fp = fopen(filename, "rb");

    char type[10];
    int maxval;

    char *line = NULL;
    size_t len = 0;

    getline(&line, &len, fp);
    sscanf(line, "%s", type); // P5 or P6
    getline(&line, &len, fp); // Generated by Gimp
    getline(&line, &len, fp); // width and height
    sscanf(line, "%d%d", width, height);
    getline(&line, &len, fp);
    sscanf(line, "%d", &maxval);

    Channels **img = (Channels **)calloc(*height, sizeof(Channels *));

    for (int i = 0; i < *height; i++)
        img[i] = (Channels *)calloc(*width, sizeof(Channels));

    for (int i = 0; i < *height; i++)
        for (int j = 0; j < *width; j++)
        {
            unsigned char r, g, b;
            fread(&r, 1, 1, fp);
            fread(&g, 1, 1, fp);
            fread(&b, 1, 1, fp);

            img[i][j].channel[0] = r;
            img[i][j].channel[1] = g;
            img[i][j].channel[2] = b;
        }

    fclose(fp);

    return img;
}

// Gets the distribution range of the array, useful if there is no normalization
int get_range(Channels **img, int width, int height)
{
    int top = 0;
    for (int i = 0; i < height; i++)
        for (int j = 0; j < width; j++)
        {
            top = fmax(top, img[i][j].channel[0]);
            top = fmax(top, img[i][j].channel[1]);
            top = fmax(top, img[i][j].channel[2]);
        }

    return top;
}

// Writes a channels array as a RGB, pnm binary image
void write_image_pnm(Channels **img, char *filename, int width, int height)
{
    FILE *out = fopen(filename, "wb");

    int top = get_range(img, width, height);
    fprintf(out, "%s\n%d %d\n%d\n", "P6", width, height, top);

    for (int i = 0; i < height; i++)
        for (int j = 0; j < width; j++)
        {
            fwrite(&img[i][j].channel[0], 1, 1, out);
            fwrite(&img[i][j].channel[1], 1, 1, out);
            fwrite(&img[i][j].channel[2], 1, 1, out);
        }
    fclose(out);
}

// Simulates a learned kernel by randomly generating it
float *get_kernel(int kernel_id)
{
    srand(kernel_id);
    float *K = malloc(channel_count * sizeof(float));
    for (int i = 0; i < channel_count; i++)
        K[i] = (rand() % 1000 + 500) / 1000.f / channel_count;

    return K;
}

// Allocates memory for a channel array
Channels **new_channel_array(int height, int width)
{
    Channels **bordered_img = (Channels **)calloc((height), sizeof(Channels *));

    for (int i = 0; i < height; i++)
        bordered_img[i] = (Channels *)calloc(width, sizeof(Channels));

    return bordered_img;
}
